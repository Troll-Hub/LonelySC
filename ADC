-- LocalScript para entornos tipo KRNL / Executor
-- Versión: prefijo 'n/' (antes 'npc/'), verificación robusta Player vs NPC,
-- LocalPlayer siempre owner, notificaciones restauradas,
-- búsqueda de NPCs en Workspace:GetDescendants() (soporta carpetas).

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer

-- CONFIG
local roles = {}               -- roles[UserId] = "owner" / "admin"
local adminUsage = {}
local ABUSE_THRESHOLD = 5
local ABUSE_TIMEFRAME = 10
local ABUSE_PUNISH_DURATION = 30

local punishBlacklist = {}

-- Forzar LocalPlayer = owner (NUNCA CAMBIAR)
roles[LocalPlayer.UserId] = "owner"

-- UTIL: enviar notificación local: intento SendNotification, si falla uso ChatMakeSystemMessage
local function notify(title, text, duration)
    duration = duration or 4
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = tostring(title or "Info"),
            Text = tostring(text or ""),
            Duration = duration
        })
    end)
    -- fallback
    pcall(function()
        StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = "["..tostring(title).."] "..tostring(text);
        })
    end)
end

-- UTIL: normalizar cadenas
local function normalizeString(s)
    if not s then return "" end
    s = tostring(s)
    s = s:match("^%s*(.-)%s*$") or s
    return string.lower(s)
end

-- UTIL: unir args desde índice i hasta el final (para nombres con espacios)
local function joinArgs(args, i)
    i = i or 1
    if i > #args then return "" end
    local t = {}
    for j = i, #args do table.insert(t, args[j]) end
    return table.concat(t, " ")
end

-- UTIL: detectar si input usa el prefijo 'n/' (antes 'npc/')
local function isNInput(rawInput)
    if not rawInput then return false end
    local s = normalizeString(tostring(rawInput))
    return s:sub(1,2) == "n."
end

-- UTIL: comprobar si un objeto del workspace es un NPC válido
-- Reglas: debe ser Model, tener Humanoid, tener children, y no corresponder a un Player (evita Characters)
local function isValidNPCModel(obj)
    if not obj then return false end
    if not obj:IsA("Model") then return false end
    if not obj:FindFirstChildOfClass("Humanoid") then return false end
    if #obj:GetChildren() == 0 then return false end
    if Players:FindFirstChild(obj.Name) then return false end -- si un Player con este nombre existe -> ignorar
    return true
end

-- Buscar NPCs en Workspace por término (usa GetDescendants para soportar carpetas)
local function findNPCsByTerm(term)
    term = normalizeString(term or "")
    local results = {}
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if isValidNPCModel(obj) then
            if term == "" or term == "all" then
                table.insert(results, obj)
            else
                if normalizeString(obj.Name):find(term, 1, true) then
                    table.insert(results, obj)
                end
            end
        end
    end
    return results
end

-- Buscar players por término (matching parcial en Name o DisplayName)
local function findPlayersByTerm(term, sender)
    term = normalizeString(term or "")
    local results = {}

    if term == "all" then
        for _, p in ipairs(Players:GetPlayers()) do table.insert(results, p) end
        return results
    elseif term == "others" then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= sender then table.insert(results, p) end
        end
        return results
    elseif term == "me" then
        table.insert(results, sender)
        return results
    end

    for _, p in ipairs(Players:GetPlayers()) do
        local n1 = normalizeString(p.Name)
        local n2 = normalizeString(p.DisplayName or p.Name)
        if term ~= "" and (n1:find(term, 1, true) or n2:find(term, 1, true)) then
            table.insert(results, p)
        end
    end
    return results
end

-- MAIN: obtener targets dado el input del usuario
-- Retorna (lista, "Player"|"NPC"|"Unknown")
local function getTargetsFromInput(rawInput, admin)
    admin = admin or LocalPlayer
    local input = normalizeString(tostring(rawInput or ""))

    -- Si usa prefijo 'n/' -> solo buscar NPCs (n/all, n/others soportados)
    if isNInput(input) then
        local sub = input:sub(3) or "" -- quitar 'n/'
        sub = sub:gsub("^%s*(.-)%s*$", "%1")

        -- n/all -> todos los NPCs válidos
        if sub == "" or sub == "all" then
            local npcs = findNPCsByTerm("")
            return npcs, "NPC"
        end

        -- n/others -> todos los NPCs excepto aquellos cuyo nombre coincide con el admin
        if sub == "others" then
            local npcs = {}
            for _, npc in ipairs(findNPCsByTerm("")) do
                if normalizeString(npc.Name) ~= normalizeString(admin.Name) then
                    table.insert(npcs, npc)
                end
            end
            return npcs, "NPC"
        end

        -- n/me -> NPCs cuyo nombre coincide con el admin? (poco útil) -> lo mapeamos a buscar por nombre normal
        if sub == "me" then
            local npcs = {}
            for _, npc in ipairs(findNPCsByTerm(normalizeString(admin.Name))) do
                table.insert(npcs, npc)
            end
            return npcs, "NPC"
        end

        -- término específico -> buscar NPCs con matching parcial (pero siempre ignorando cualquier modelo que corresponda a Player)
        local npcs = findNPCsByTerm(sub)
        return npcs, "NPC"
    end

    -- No usa 'n/' -> priorizar Players
    local players = findPlayersByTerm(input, admin)
    if #players > 0 then
        return players, "Player"
    end

    -- Si no hay players -> intentar buscar NPCs (sin prefijo)
    local npcs = findNPCsByTerm(input)
    if #npcs > 0 then
        return npcs, "NPC"
    end

    return {}, "Unknown"
end

-- REGISTRO DE USOS (detección de abuso)
local function registerCommandUsage(admin, cmd, target)
    if not admin or roles[admin.UserId] ~= "admin" then return false end
    adminUsage[admin.UserId] = adminUsage[admin.UserId] or {}
    adminUsage[admin.UserId][cmd] = adminUsage[admin.UserId][cmd] or {}
    local targetId = tostring((type(target) == "table" and (target.UserId or target.Name)) or target)
    adminUsage[admin.UserId][cmd][targetId] = adminUsage[admin.UserId][cmd][targetId] or {}
    local usageList = adminUsage[admin.UserId][cmd][targetId]
    local now = tick()
    table.insert(usageList, now)
    for i = #usageList, 1, -1 do
        if now - usageList[i] > ABUSE_TIMEFRAME then
            table.remove(usageList, i)
        end
    end
    return (#usageList >= ABUSE_THRESHOLD)
end

local function punishAbusiveAdmin(admin)
    if not admin then return end
    if admin.Character and admin.Character:FindFirstChild("Humanoid") then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, admin.Character, CFrame.new(math.huge, math.huge, math.huge))
            end
        end)
        notify("Admin Ranker", "Admin "..admin.Name.." abusó de comandos. Castigado temporalmente.", 5)
        delay(ABUSE_PUNISH_DURATION, function()
            if admin.Character then
                pcall(function()
                    if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                        ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, admin.Character)
                    end
                end)
            end
            roles[admin.UserId] = nil
            notify("Admin Ranker", "Admin "..admin.Name.." perdió permisos por abuso.", 4)
        end)
    end
end

-- FUNCIONES DE ACCIÓN (PLAYERS)
local function bring(admin, target)
    if not (target and admin) then return end
    if target.Character and target.Character.PrimaryPart and admin.Character and admin.Character.PrimaryPart then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, target.Character, admin.Character.PrimaryPart.CFrame)
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, target.Character)
            end
        end)
        notify("Bring", admin.Name.." trajo a "..target.Name, 3)
    end
end

local function kill(admin, target)
    if not (target and admin) then return end
    local humanoid = target.Character and target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, 1e111, admin)
            end
        end)
        notify("Kill", admin.Name.." mató a "..target.Name, 3)
    end
end

local function heal(admin, target)
    if not (target and admin) then return end
    local humanoid = target.Character and target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, -1e9, admin)
            end
        end)
        notify("Heal", admin.Name.." sanó a "..target.Name, 3)
    end
end

local function god(admin, target)
    if not (target and admin) then return end
    local humanoid = target.Character and target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, -1e111, admin)
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, 1e111, admin)
            end
        end)
        notify("God", admin.Name.." aplicó god a "..target.Name, 3)
    end
end

local function killer(admin, target)
    if not (target and admin) then return end
    if target.Character then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, target.Character, CFrame.new(math.huge, math.huge, math.huge))
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, target.Character)
            end
        end)
        punishBlacklist[target.UserId] = true
        notify("Killer", admin.Name.." usó killer en "..target.Name, 3)
    end
end

-- FUNCIONES DE ACCIÓN (NPCs)
local function applyPunishToModel(admin, model)
    if not (model and admin) then return end
    if model:FindFirstChildOfClass("Humanoid") then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, model, model.PrimaryPart and model.PrimaryPart.CFrame or CFrame.new())
            end
        end)
    end
end

local function killNPC(admin, npc)
    if not (admin and npc) then return end
    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, 1e111, admin)
            end
        end)
        notify("Kill (NPC)", admin.Name.." mató NPC "..npc.Name, 3)
    end
end

local function godNPC(admin, npc)
    if not (admin and npc) then return end
    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, -1e111, admin)
                ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, 1e111, admin)
            end
        end)
        notify("God (NPC)", admin.Name.." aplicó god a NPC "..npc.Name, 3)
    end
end

local function killerNPC(admin, npc)
    if not (admin and npc) then return end
    if npc.PrimaryPart then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, npc, CFrame.new(math.huge, math.huge, math.huge))
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, npc)
            end
        end)
        punishBlacklist[npc.Name] = true
        notify("Killer (NPC)", admin.Name.." usó killer en NPC "..npc.Name, 3)
    end
end

-- AUX: findDB1, bCommand, rank/unrank, fs, cmds (mantenemos como antes)
local function findDB1()
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and normalizeString(obj.Name) == "db1" then
            return obj
        end
    end
    return nil
end

local function bCommand(admin, target)
    if not (target and admin) then return end
    if roles[admin.UserId] ~= "owner" then
        notify("B", "No tienes permiso para usar .b", 4)
        return
    end
    local dbPart = findDB1()
    if dbPart then
        pcall(function()
            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, target.Character, dbPart.CFrame)
                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, target.Character)
            end
        end)
        notify("B", "DB1 teleported "..target.Name, 3)
    else
        notify("B", "DB1 no encontrado.", 4)
    end
end

local function fsCommand(admin, term)
    if not (admin) then return end
    notify("FS", "FS ejecutado: "..tostring(term), 3)
end

local function rankCommand(admin, target)
    if not (admin and target) then return end
    roles[target.UserId] = "admin"
    notify("Rank", "Jugador "..target.Name.." fue rankeado admin por "..admin.Name, 3)
end

local function unrankCommand(admin, target)
    if not (admin and target) then return end
    roles[target.UserId] = nil
    notify("Unrank", "Jugador "..target.Name.." perdió rank por "..admin.Name, 3)
end

local function cmdsCommand(admin)
    if not (admin) then return end
    notify("Cmds", "Comandos: .bring .kill .heal .god .killer .punish .unpunish .freeze .unfreeze .b .to .rank .unrank .fs .cmds", 4)
end

-- PROCESAR COMANDO (usa getTargetsFromInput para decidir Player vs NPC)
local function processAdminCommand(admin, rawMessage)
    if type(rawMessage) ~= "string" then return end
    if string.sub(rawMessage, 1, 1) ~= "." then return end
    if not roles[admin.UserId] then return end

    -- Tokenizar
    local args = {}
    for word in rawMessage:gmatch("%S+") do table.insert(args, word) end
    if #args < 1 then return end
    local cmd = string.lower(string.sub(args[1], 2))
    local targetInput = joinArgs(args, 2)

    local targets, ttype = getTargetsFromInput(targetInput, admin)

    if ttype == "Unknown" or #targets < 1 then
        notify("Admin Ranker", "No se encontró target que coincida.", 3)
        return
    end

    if ttype == "NPC" then
        -- Ejecutar comando sobre NPCs (lista de modelos)
        if cmd == "fs" then
            fsCommand(admin, targetInput)
        elseif cmd == "bring" then
            for _, npc in ipairs(targets) do
                if npc:FindFirstChildOfClass("Humanoid") and admin.Character and admin.Character.PrimaryPart then
                    pcall(function()
                        if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                            ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, npc, admin.Character.PrimaryPart.CFrame)
                            ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, npc)
                        end
                    end)
                    notify("Bring (NPC)", admin.Name.." trajo NPC "..npc.Name, 3)
                end
            end
        elseif cmd == "kill" then
            for _, npc in ipairs(targets) do
                killNPC(admin, npc)
                if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "kill", npc) then punishAbusiveAdmin(admin) end
            end
        elseif cmd == "heal" then
            for _, npc in ipairs(targets) do
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    pcall(function()
                        if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("TakeDamage") then
                            ReplicatedStorage._BindableEvents.Moves.TakeDamage:FireServer(humanoid, -1e9, admin)
                        end
                    end)
                    notify("Heal (NPC)", admin.Name.." sanó NPC "..npc.Name, 3)
                end
            end
        elseif cmd == "punish" then
            for _, npc in ipairs(targets) do
                applyPunishToModel(admin, npc)
                notify("Punish (NPC)", admin.Name.." punishó NPC "..npc.Name, 3)
            end
        elseif cmd == "unpunish" then
            for _, npc in ipairs(targets) do
                local uid = npc.Name
                if punishBlacklist[uid] then
                    punishBlacklist[uid] = nil
                    pcall(function()
                        if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") and ReplicatedStorage._BindableEvents.Moves:FindFirstChild("StopEnemy") then
                            ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, npc)
                        end
                    end)
                    notify("Unpunish (NPC)", admin.Name.." removió punish NPC "..npc.Name, 3)
                end
            end
        elseif cmd == "freeze" then
            for _, npc in ipairs(targets) do
                if npc:FindFirstChildOfClass("Humanoid") and npc.PrimaryPart then
                    pcall(function()
                        if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                            ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, npc, npc.PrimaryPart.CFrame)
                        end
                    end)
                    if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "freeze", npc) then punishAbusiveAdmin(admin) end
                    notify("Freeze (NPC)", admin.Name.." congeló NPC "..npc.Name, 3)
                end
            end
        elseif cmd == "unfreeze" then
            for _, npc in ipairs(targets) do
                pcall(function()
                    if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                        ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, npc)
                    end
                end)
                notify("Unfreeze (NPC)", admin.Name.." descongeló NPC "..npc.Name, 3)
            end
        elseif cmd == "god" then
            for _, npc in ipairs(targets) do
                godNPC(admin, npc)
                if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "god", npc) then punishAbusiveAdmin(admin) end
            end
        elseif cmd == "killer" then
            for _, npc in ipairs(targets) do
                killerNPC(admin, npc)
                if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "killer", npc) then punishAbusiveAdmin(admin) end
            end
        elseif cmd == "b" then
            local dbPart = findDB1()
            if dbPart then
                for _, npc in ipairs(targets) do
                    if npc:FindFirstChildOfClass("Humanoid") and npc.PrimaryPart then
                        pcall(function()
                            if ReplicatedStorage:FindFirstChild("_BindableEvents") and ReplicatedStorage._BindableEvents:FindFirstChild("Moves") then
                                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(true, npc, dbPart.CFrame)
                                ReplicatedStorage._BindableEvents.Moves.StopEnemy:FireServer(false, npc)
                            end
                        end)
                        notify("B (NPC)", admin.Name.." usó .b en NPC "..npc.Name, 3)
                    end
                end
            else
                notify("B", "DB1 no encontrado.", 4)
            end
        else
            notify("Admin Ranker", "Comando desconocido para NPCs: "..cmd, 3)
        end

        return
    end

    -- Si ttype == "Player"
    if ttype == "Player" then
        if cmd == "cmds" then
            cmdsCommand(admin)
        elseif cmd == "bring" then
            for _, t in ipairs(targets) do bring(admin, t) end
        elseif cmd == "kill" then
            for _, t in ipairs(targets) do kill(admin, t); if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "kill", t) then punishAbusiveAdmin(admin) end end
        elseif cmd == "heal" then
            for _, t in ipairs(targets) do heal(admin, t) end
        elseif cmd == "god" then
            for _, t in ipairs(targets) do god(admin, t); if roles[admin.UserId] == "admin" and registerCommandUsage(admin, "god", t) then punishAbusiveAdmin(admin) end end
        elseif cmd == "killer" then
            for _, t in ipairs(targets) do killer(admin, t) end
        elseif cmd == "punish" then
            for _, t in ipairs(targets) do punishPlayer(admin, t) end
        elseif cmd == "unpunish" then
            for _, t in ipairs(targets) do unpunishPlayer(admin, t) end
        elseif cmd == "freeze" then
            for _, t in ipairs(targets) do freeze(admin, t) end
        elseif cmd == "unfreeze" then
            for _, t in ipairs(targets) do unfreeze(admin, t) end
        elseif cmd == "b" then
            for _, t in ipairs(targets) do bCommand(admin, t) end
        elseif cmd == "to" then
            for _, t in ipairs(targets) do toCommand(admin, t) end
        elseif cmd == "rank" then
            for _, t in ipairs(targets) do rankCommand(admin, t) end
        elseif cmd == "unrank" then
            for _, t in ipairs(targets) do unrankCommand(admin, t) end
        elseif cmd == "fs" then
            fsCommand(admin, targetInput)
        else
            notify("Admin Ranker", "Comando desconocido: "..cmd, 3)
        end
        return
    end

    notify("Admin Ranker", "Target no reconocido.", 3)
end

-- CONEXIONES: Escuchar chat de todos los jugadores (Player.Chatted)
local function connectPlayerChat(p)
    p.Chatted:Connect(function(msg)
        processAdminCommand(p, msg)
    end)
end

for _, p in ipairs(Players:GetPlayers()) do
    connectPlayerChat(p)
end
Players.PlayerAdded:Connect(function(p) connectPlayerChat(p) end)

-- LocalPlayer también conectado
LocalPlayer.Chatted:Connect(function(msg) processAdminCommand(LocalPlayer, msg) end)

notify("Admin Ranker", "Script cargado y listo. Usa '.' para comandos. Para NPCs usa 'n/'. LocalPlayer = owner.", 5)
